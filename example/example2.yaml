---
apiVersion: specs.smi-spec.io/v1alpha1
kind: HTTPRouteGroup
metadata:
  name: service-a-http
matches:
  - name: getter
    pathRegex: /
    methods: ["GET"]
  - name: poster
    pathRegex: /
    methods: ["POST"]


## Old View
---
kind: TrafficTarget
apiVersion: access.smi-spec.io/v1alpha1
metadata:
  name: service-a-api-get
  namespace: default
selector:
  matchLabels:
    app: service-a
specs:
- kind: HTTPRouteGroup
  name: service-a-http
  matches:
    - getter

---
kind: IdentityBinding
apiVersion: access.smi-spec.io/v1alpha1
metadata:
  name: service-a-getters
  namespace: default
subjects:
- kind: ServiceAccount
  name: service-b
  namespace: default
- kind: ServiceAccount
  name: service-d
  namespace: default
- kind: ServiceAccount
  name: service-e
  namespace: default
targetRef:
  kind: TrafficTarget
  name: service-a-api-get

---
kind: TrafficTarget
apiVersion: access.smi-spec.io/v1alpha1
metadata:
  name: service-a-api-post-get
  namespace: default
selector:
  matchLabels:
    app: service-a
specs:
- kind: HTTPRouteGroup
  name: service-a-http
  matches:
    - poster
    - getter

---
kind: IdentityBinding
apiVersion: access.smi-spec.io/v1alpha1
metadata:
  name: service-a-posters
  namespace: default
subjects:
- kind: ServiceAccount
  name: service-b
  namespace: default
- kind: ServiceAccount
  name: service-c
  namespace: default
targetRef:
  kind: TrafficTarget
  name: service-a-api-post-get

# Gives us the following rules
# service-b -> service-a-get // defined in 1st and second
# service-b -> service-a-get
# service-c -> service-a-get
# service-d -> service-a-get
# service-e -> service-a-get
# service-b -> service-a-post
# service-c -> service-a-post

# if we delete the first rule without understanding the big picture you get this
# inadvertently we delete service-b -> service-a-get even though it is defined
# in the second
# service-c -> service-a-get
# service-d -> service-a-get
# service-e -> service-a-get
# service-b -> service-a-post
# service-c -> service-a-post

Problem is building this world view with the first model we must do the following

binding = getCurrentBinding()
target = getCurrentTarget(binding)
pods = getPods(target)
for pod in pods {
  mainServiceAccount = getServiceAccount(pod)
}

// find other targets with same service account
targets = getAllTargets()
filteredTargets = []

for t in targets {
  pods = getPods(t)
  for pod in pods {
    serviceAccount = getServiceAccount(pod)
  }

  if serviceAccount == mainServiceAccount {
    filteredTargets.add(t)
  }
}

// find all identity binding which match filteredTargets
filteredBindings = []
bindings = getAllBindings()
for b in bindings {
  for t in filteredTargets {
    if b.Target = t.Name {
      filteredBindings.add(b)
    }
  }
}

## TrafficTarget
---
kind: TrafficTarget
apiVersion: access.smi-spec.io/v1alpha1
metadata:
 name: service-a-api-get
 namespace: default
destination:
 kind: ServiceAccount
 name: service-a
 namespace: default
specs:
- kind: HTTPRouteGroup
  name: service-a-http
  matches:
    - getter
sources:
- kind: ServiceAccount
 name: service-b
 namespace: default
- kind: ServiceAccount
 name: service-d
 namespace: default
- kind: ServiceAccount
 name: service-e
 namespace: default

---
kind: TrafficTarget
apiVersion: access.smi-spec.io/v1alpha1
metadata:
 name: service-a-api-post-get
 namespace: default
destination:
 kind: ServiceAccount
 name: service-a
 namespace: default
specs:
- kind: HTTPRouteGroup
  name: service-a-http
  matches:
    - getter
- kind: HTTPRouteGroup
  name: service-a-http
  matches:
    - poster
sources:
- kind: ServiceAccount
 name: service-b
 namespace: default
- kind: ServiceAccount
 name: service-c
 namespace: default

With new model we would have to ....
filteredTargets = []
curentTarget = getCurrentTarget() 
targets = getAllTargets() 

for t in targets {
  if t.destination == currentTarget.destination && t.specs == currentTarget.specs {
    filteredTargets.add(t)
  } 
}

// we now have a world view